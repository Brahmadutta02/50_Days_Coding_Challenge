/* Detect-zoom * ----------- * Cross Browser Zoom and Pixel Ratio Detector * Version 1.0.4 | Apr 1 2013 * dual-licensed under the WTFPL and MIT license * Maintained by https://github/tombigel * Original developer https://github.com/yonran */ //AMD and
CommonJS initialization copied from https://github.com/zohararad/audio5js (function (root, ns, factory) { "use strict"; if (typeof (module) !== 'undefined' && module.exports) { // CommonJS module.exports = factory(ns, root); } else if (typeof (define)
=== 'function' && define.amd) { // AMD define("factory", function () { return factory(ns, root); }); } else { root[ns] = factory(ns, root); } }(window, 'detectZoom', function () { /** * Use devicePixelRatio if supported by the browser * @return {Number}
* @private */ var devicePixelRatio = function () { return window.devicePixelRatio || 1; }; /** * Fallback function to set default values * @return {Object} * @private */ var fallback = function () { return { zoom: 1, devicePxPerCssPx: 1 }; }; /** * IE
8 and 9: no trick needed! * TODO: Test on IE10 and Windows 8 RT * @return {Object} * @private **/ var ie8 = function () { var zoom = Math.round((screen.deviceXDPI / screen.logicalXDPI) * 100) / 100; return { zoom: zoom, devicePxPerCssPx: zoom * devicePixelRatio()
}; }; /** * For IE10 we need to change our technique again... * thanks https://github.com/stefanvanburen * @return {Object} * @private */ var ie10 = function () { var zoom = Math.round((document.documentElement.offsetHeight / window.innerHeight) * 100)
/ 100; return { zoom: zoom, devicePxPerCssPx: zoom * devicePixelRatio() }; }; /** * Mobile WebKit * the trick: window.innerWIdth is in CSS pixels, while * screen.width and screen.height are in system pixels. * And there are no scrollbars to mess up the
measurement. * @return {Object} * @private */ var webkitMobile = function () { var deviceWidth = (Math.abs(window.orientation) == 90) ? screen.height : screen.width; var zoom = deviceWidth / window.innerWidth; return { zoom: zoom, devicePxPerCssPx: zoom
* devicePixelRatio() }; }; /** * Desktop Webkit * the trick: an element's clientHeight is in CSS pixels, while you can * set its line-height in system pixels using font-size and * -webkit-text-size-adjust:none. * device-pixel-ratio: http://www.webkit.org/blog/55/high-dpi-web-sites/
* * Previous trick (used before http://trac.webkit.org/changeset/100847): * documentElement.scrollWidth is in CSS pixels, while * document.width was in system pixels. Note that this is the * layout width of the document, which is slightly different from
viewport * because document width does not include scrollbars and might be wider * due to big elements. * @return {Object} * @private */ var webkit = function () { var important = function (str) { return str.replace(/;/g, " !important;"); }; var div =
document.createElement('div'); div.innerHTML = "1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>0"; div.setAttribute('style', important('font: 100px/1em sans-serif; -webkit-text-size-adjust: none; text-size-adjust: none; height: auto; width: 1em; padding:
0; overflow: visible;')); // The container exists so that the div will be laid out in its own flow // while not impacting the layout, viewport size, or display of the // webpage as a whole. // Add !important and relevant CSS rule resets // so that other
rules cannot affect the results. var container = document.createElement('div'); container.setAttribute('style', important('width:0; height:0; overflow:hidden; visibility:hidden; position: absolute;')); container.appendChild(div); document.body.appendChild(container);
var zoom = 1000 / div.clientHeight; zoom = Math.round(zoom * 100) / 100; document.body.removeChild(container); return{ zoom: zoom, devicePxPerCssPx: zoom * devicePixelRatio() }; }; /** * no real trick; device-pixel-ratio is the ratio of device dpi / css
dpi. * (Note that this is a different interpretation than Webkit's device * pixel ratio, which is the ratio device dpi / system dpi). * * Also, for Mozilla, there is no difference between the zoom factor and the device ratio. * * @return {Object} * @private
*/ var firefox4 = function () { var zoom = mediaQueryBinarySearch('min--moz-device-pixel-ratio', '', 0, 10, 20, 0.0001); zoom = Math.round(zoom * 100) / 100; return { zoom: zoom, devicePxPerCssPx: zoom }; }; /** * Firefox 18.x * Mozilla added support
for devicePixelRatio to Firefox 18, * but it is affected by the zoom level, so, like in older * Firefox we can't tell if we are in zoom mode or in a device * with a different pixel ratio * @return {Object} * @private */ var firefox18 = function () { return
{ zoom: firefox4().zoom, devicePxPerCssPx: devicePixelRatio() }; }; /** * works starting Opera 11.11 * the trick: outerWidth is the viewport width including scrollbars in * system px, while innerWidth is the viewport width including scrollbars * in CSS
px * @return {Object} * @private */ var opera11 = function () { var zoom = window.top.outerWidth / window.top.innerWidth; zoom = Math.round(zoom * 100) / 100; return { zoom: zoom, devicePxPerCssPx: zoom * devicePixelRatio() }; }; /** * Use a binary search
through media queries to find zoom level in Firefox * @param property * @param unit * @param a * @param b * @param maxIter * @param epsilon * @return {Number} */ var mediaQueryBinarySearch = function (property, unit, a, b, maxIter, epsilon) { var matchMedia;
var head, style, div; if (window.matchMedia) { matchMedia = window.matchMedia; } else { head = document.getElementsByTagName('head')[0]; style = document.createElement('style'); head.appendChild(style); div = document.createElement('div'); div.className
= 'mediaQueryBinarySearch'; div.style.display = 'none'; document.body.appendChild(div); matchMedia = function (query) { style.sheet.insertRule('@media ' + query + '{.mediaQueryBinarySearch ' + '{text-decoration: underline} }', 0); var matched = getComputedStyle(div,
null).textDecoration == 'underline'; style.sheet.deleteRule(0); return {matches: matched}; }; } var ratio = binarySearch(a, b, maxIter); if (div) { head.removeChild(style); document.body.removeChild(div); } return ratio; function binarySearch(a, b, maxIter)
{ var mid = (a + b) / 2; if (maxIter
<=0 || b - a < epsilon) { return mid; } var query="(" + property + ":" + mid + unit + ")"; if (matchMedia(query).matches) { return binarySearch(mid, b, maxIter - 1); } else { return binarySearch(a, mid, maxIter - 1);
    } } }; /** * Generate detection function * @private */ var detectFunction=( function () { var func=f allback; //IE8+ if (!isNaN(screen.logicalXDPI) && !isNaN(screen.systemXDPI)) { func=i e8; } // IE10+ / Touch else if (window.navigator.msMaxTouchPoints)
    { func=i e10; } //Mobile Webkit else if ( 'orientation' in window && typeof document.body.style.webkitMarquee==='string' ) { func=w ebkitMobile; } //WebKit else if (typeof document.body.style.webkitMarquee==='string' ) { func=w ebkit; } //Opera else if
    (navigator.userAgent.indexOf( 'Opera')>= 0) { func = opera11; } //Last one is Firefox //FF 18.x else if (window.devicePixelRatio) { func = firefox18; } //FF 4.0 - 17.x else if (firefox4().zoom > 0.001) { func = firefox4; } return func; }()); return ({ /** * Ratios.zoom shorthand * @return
    {Number} Zoom level */ zoom: function () { return detectFunction().zoom; }, /** * Ratios.devicePxPerCssPx shorthand * @return {Number} devicePxPerCssPx level */ device: function () { return detectFunction().devicePxPerCssPx; } }); })); var wpcom_img_zoomer
    = { clientHintSupport: { gravatar: false, files: false, photon: false, mshots: false, staticAssets: false, latex: false, imgpress: false, }, useHints: false, zoomed: false, timer: null, interval: 1000, // zoom polling interval in millisecond // Should
    we apply width/height attributes to control the image size? imgNeedsSizeAtts: function( img ) { // Do not overwrite existing width/height attributes. if ( img.getAttribute('width') !== null || img.getAttribute('height') !== null ) return false; //
    Do not apply the attributes if the image is already constrained by a parent element. if ( img.width
    < img.naturalWidth || img.height < img.naturalHeight ) return false; return true; }, hintsFor: function( service ) { if ( this.useHints===f alse )
        { return false; } if ( this.hints()===f alse ) { return false; } if ( typeof this.clientHintSupport[service]==="undefined" ) { return false; } if ( this.clientHintSupport[service]===t rue ) { return true; } return false; }, hints: function() { try
        { var chrome=w indow.navigator.userAgent.match(/\sChrome\/([0-9]+)\.[.0-9]+\s/) if (chrome !==n ull) { var version=p arseInt(chrome[1], 10) if (isNaN(version)===f alse && version>= 46) { return true } } } catch (e) { return false } return false }, init: function() { var t = this; try{ t.zoomImages(); t.timer = setInterval( function() { t.zoomImages(); }, t.interval ); } catch(e){ } }, stop: function() { if ( this.timer ) clearInterval(
        this.timer ); }, getScale: function() { var scale = detectZoom.device(); // Round up to 1.5 or the next integer below the cap. if ( scale
        <=1 .0 ) scale=1 .0; else if ( scale <=1 .5 ) scale=1 .5; else if ( scale <=2 .0 ) scale=2 .0; else if (
            scale <=3 .0 ) scale=3 .0; else if ( scale <=4 .0 ) scale=4 .0; else scale=5 .0; return scale; }, shouldZoom: function( scale ) { var t=t his; // Do not operate on hidden frames. if ( "innerWidth" in window && !window.innerWidth ) return false;
        // Don 't do anything until scale > 1
		if ( scale == 1.0 && t.zoomed == false )
			return false;
		return true;
	},

	zoomImages: function() {
		var t = this;
		var scale = t.getScale();
		if ( ! t.shouldZoom( scale ) ){
			return;
		}
		t.zoomed = true;
		// Loop through all the <img> elements on the page.
		var imgs = document.getElementsByTagName("img");

		for ( var i = 0; i < imgs.length; i++ ) {
			// Wait for original images to load
			if ( "complete" in imgs[i] && ! imgs[i].complete )
				continue;

			// Skip images that have srcset attributes.
			if ( imgs[i].hasAttribute('srcset ') ) {
				continue;
			}

			// Skip images that don't need processing. var imgScale=i mgs[i].getAttribute( "scale"); if ( imgScale==s cale || imgScale=="0" ) continue; // Skip images that have already failed at this scale var scaleFail=i mgs[i].getAttribute( "scale-fail");
            if ( scaleFail && scaleFail <=s cale ) continue; // Skip images that have no dimensions yet. if ( ! ( imgs[i].width && imgs[i].height ) ) continue; // Skip images from Lazy Load plugins if ( ! imgScale && imgs[i].getAttribute( "data-lazy-src")
            && (imgs[i].getAttribute( "data-lazy-src") !==i mgs[i].getAttribute( "src"))) continue; if ( t.scaleImage( imgs[i], scale ) ) { // Mark the img as having been processed at this scale. imgs[i].setAttribute( "scale", scale); } else { // Set the
            flag to skip this image. imgs[i].setAttribute( "scale", "0"); } } }, scaleImage: function( img, scale ) { var t=t his; var newSrc=i mg.src; var isFiles=f alse; var isLatex=f alse; var isPhoton=f alse; // Skip slideshow images if ( img.parentNode.className.match(/slideshow-slide/)
            ) return false; // Skip CoBlocks Lightbox images if ( img.parentNode.className.match(/coblocks-lightbox__image/) ) return false; // Scale gravatars that have ?s=o r ?size=i f ( img.src.match( /^https?:\/\/([^\/]*\.)?gravatar\.com\/.+[?&](s|size)=/
            ) ) { if ( this.hintsFor( "gravatar" )===t rue ) { return false; } newSrc=i mg.src.replace( /([?&](s|size)=)(\d+)/, function( $0, $1, $2, $3 ) { // Stash the original size var originalAtt="originals" , originalSize=i mg.getAttribute(originalAtt);
            if ( originalSize===n ull ) { originalSize=$ 3; img.setAttribute(originalAtt, originalSize); if ( t.imgNeedsSizeAtts( img ) ) { // Fix width and height attributes to rendered dimensions. img.width=i mg.width; img.height=i mg.height; } } // Get
            the width/height of the image in CSS pixels var size=i mg.clientWidth; // Convert CSS pixels to device pixels var targetSize=M ath.ceil(img.clientWidth * scale); // Don 't go smaller than the original size
				targetSize = Math.max( targetSize, originalSize );
				// Don't go larger than the service supports targetSize=M ath.min( targetSize, 512 ); return $1 + targetSize; }); } // Scale mshots that have width else if ( img.src.match(/^https?:\/\/([^\/]+\.)*(wordpress|wp)\.com\/mshots\/.+[?&]w=\d+/) ) { if
            ( this.hintsFor( "mshots" )===t rue ) { return false; } newSrc=i mg.src.replace( /([?&]w=)(\d+)/, function($0, $1, $2) { // Stash the original size var originalAtt='originalw' , originalSize=i mg.getAttribute(originalAtt); if ( originalSize===n
            ull ) { originalSize=$ 2; img.setAttribute(originalAtt, originalSize); if ( t.imgNeedsSizeAtts( img ) ) { // Fix width and height attributes to rendered dimensions. img.width=i mg.width; img.height=i mg.height; } } // Get the width of the image
            in CSS pixels var size=i mg.clientWidth; // Convert CSS pixels to device pixels var targetSize=M ath.ceil(size * scale); // Don 't go smaller than the original size
				targetSize = Math.max( targetSize, originalSize );
				// Don't go bigger unless the current one is actually lacking if ( scale> img.getAttribute("scale") && targetSize
            <=i mg.naturalWidth ) targetSize=$ 2; if ( $2 !=t argetSize ) return $1 + targetSize; return $0; }); // Update height attribute to match width newSrc=n ewSrc.replace( /([?&]h=)(\d+)/, function($0, $1, $2)
                { if ( newSrc==i mg.src ) { return $0; } // Stash the original size var originalAtt='originalh' , originalSize=i mg.getAttribute(originalAtt); if ( originalSize===n ull ) { originalSize=$ 2; img.setAttribute(originalAtt, originalSize); } //
                Get the height of the image in CSS pixels var size=i mg.clientHeight; // Convert CSS pixels to device pixels var targetSize=M ath.ceil(size * scale); // Don 't go smaller than the original size
				targetSize = Math.max( targetSize, originalSize );
				// Don't go bigger unless the current one is actually lacking if ( scale> img.getAttribute("scale") && targetSize
                <=i mg.naturalHeight ) targetSize=$ 2; if ( $2 !=t argetSize ) return $1 + targetSize; return $0; }); } // Scale simple imgpress queries (s0.wp.com) that only specify w/h/fit else if ( img.src.match(/^https?:\/\/([^\/.]+\.)*(wp|wordpress)\.com\/imgpress\?(.+)/)
                    ) { if ( this.hintsFor( "imgpress" )===t rue ) { return false; } var imgpressSafeFunctions=[ "zoom", "url", "h", "w", "fit", "filter", "brightness", "contrast", "colorize", "smooth", "unsharpmask"]; // Search the query string for unsupported
                    functions. var qs=R egExp.$3.split( '&'); for ( var q in qs ) { q=q s[q].split( '=')[0]; if ( imgpressSafeFunctions.indexOf(q)==- 1 ) { return false; } } // Fix width and height attributes to rendered dimensions. img.width=i mg.width;
                    img.height=i mg.height; // Compute new src if ( scale==1 ) newSrc=i mg.src.replace(/\?(zoom=[^&]+&)?/, '?'); else newSrc=i mg.src.replace(/\?(zoom=[^&]+&)?/, '?zoom=' + scale + '&'); } // Scale files.wordpress.com, LaTeX, or Photon images
                    (i#.wp.com) else if ( ( isFiles=i mg.src.match(/^https?:\/\/([^\/]+)\.files\.wordpress\.com\/.+[?&][wh]=/) ) || ( isLatex=i mg.src.match(/^https?:\/\/([^\/.]+\.)*(wp|wordpress)\.com\/latex\.php\?(latex|zoom)=(.+)/) ) || ( isPhoton=i mg.src.match(/^https?:\/\/i[\d]{1}\.wp\.com\/(.+)/)
                    ) ) { if ( false !==i sFiles && this.hintsFor( "files" )===t rue ) { return false } if ( false !==i sLatex && this.hintsFor( "latex" )===t rue ) { return false } if ( false !==i sPhoton && this.hintsFor( "photon" )===t rue ) { return false
                    } // Fix width and height attributes to rendered dimensions. img.width=i mg.width; img.height=i mg.height; // Compute new src if ( scale==1 ) { newSrc=i mg.src.replace(/\?(zoom=[^&]+&)?/, '?'); } else { newSrc=i mg.src; var url_var=n ewSrc.match(
                /([?&]w=)(\d+)/ ); if ( url_var !==n ull && url_var[2] ) { newSrc=n ewSrc.replace( url_var[0], url_var[1] + img.width ); } url_var=n ewSrc.match( /([?&]h=)(\d+)/ ); if ( url_var !==n ull && url_var[2] ) { newSrc=n ewSrc.replace( url_var[0],
                    url_var[1] + img.height ); } var zoom_arg='&zoom=2' ; if ( !newSrc.match( /\?/ ) ) { zoom_arg='?zoom=2' ; } img.setAttribute( 'srcset', newSrc + zoom_arg + ' ' + scale + 'x' ); } } // Scale static assets that have a name matching *-1x.png
                    or *@1x.png else if ( img.src.match(/^https?:\/\/[^\/]+\/.*[-@]([12])x\.(gif|jpeg|jpg|png)(\?|$)/) ) { if ( this.hintsFor( "staticAssets" )===t rue ) { return false; } // Fix width and height attributes to rendered dimensions. img.width=i
                    mg.width; img.height=i mg.height; var currentSize=R egExp.$1, newSize=c urrentSize; if ( scale <=1 ) newSize=1 ; else newSize=2 ; if ( currentSize !=n ewSize ) newSrc=i mg.src.replace(/([-@])[12]x\.(gif|jpeg|jpg|png)(\?|$)/, '$1'+newSize+
                    'x.$2$3'); } else { return false; } // Don 't set img.src unless it has changed. This avoids unnecessary reloads.
		if ( newSrc != img.src ) {
			// Store the original img.src
			var prevSrc, origSrc = img.getAttribute("src-orig");
			if ( !origSrc ) {
				origSrc = img.src;
				img.setAttribute("src-orig", origSrc);
			}
			// In case of error, revert img.src
			prevSrc = img.src;
			img.onerror = function(){
				img.src = prevSrc;
				if ( img.getAttribute("scale-fail") < scale )
					img.setAttribute("scale-fail", scale);
				img.onerror = null;
			};
			// Finally load the new image
			img.src = newSrc;
		}

		return true;
	}
};

wpcom_img_zoomer.init();
;
( function() {
	var cookieValue = document.cookie.replace( /(?:(?:^|.*;\s*)eucookielaw\s*\=\s*([^;]*).*$)|^.*$/, '$1 ' );
	var overlay = document.querySelector( '#eu-cookie-law ' );
	var container = document.querySelector( '.widget_eu_cookie_law_widget ' );
	var initialScrollPosition, scrollFunction;

	function remove( el ) {
		return el && el.parentElement && el.parentElement.removeChild( el );
	}

	function triggerDismissEvent() {
		try {
			const dismissEvent = new Event( 'eucookielaw-dismissed ' );
			document.dispatchEvent( dismissEvent );
		} catch ( err ) { }
	}

	function removeOverlay() {
		remove( overlay );
		triggerDismissEvent();
	}

	function fade( el, type, fn ) {
		var duration = 400;

		el.style.display = 'block ';
		el.style.transitionProperty = 'opacity ';
		el.style.transitionDuration = duration + 'ms ';
		el.style.opacity = type === 'in ' ? 0 : 1;

		// Double rAF to ensure styles are applied cross-browser.
		requestAnimationFrame( function () {
			requestAnimationFrame( function() {
				el.style.opacity = type === 'in ' ? 1 : 0;
				// Wait for animation.
				setTimeout( function () {
					// Clean up.
					el.style.removeProperty( 'opacity ' );
					el.style.removeProperty( 'transition-property ' );
					el.style.removeProperty( 'transition-duration ' );

					if ( type === 'out ' ) {
						el.style.display = 'none ';
					}

					if ( typeof fn === 'function ' ) {
						fn();
					}
				}, duration + 50 );
			} );
		} );
	}

	function appendWidget() {
		document.body.appendChild( container );
		overlay.style.display = 'block ';
		fade( container, 'in ' );
	}

	if ( typeof wp !== 'undefined ' && !! wp.customize ) {
		appendWidget();
		return;
	}

	if ( ! overlay || ! container ) {
		return;
	}

	if ( overlay.classList.contains( 'ads-active ' ) ) {
		var adsCookieValue = document.cookie.replace( /(?:(?:^|.*;\s*)personalized-ads-consent\s*\=\s*([^;]*).*$)|^.*$/, '$1 ' );
		if ( cookieValue !== ' ' && adsCookieValue !== ' ' ) {
			removeOverlay();
		}
	} else if ( cookieValue !== ' ' ) {
		removeOverlay();
	}

	appendWidget();

	overlay.querySelector( 'form ' ).addEventListener( 'submit ', accept );

	if ( overlay.classList.contains( 'hide-on-scroll ' ) ) {
		initialScrollPosition = window.pageYOffset;

		scrollFunction = function() {
			if ( Math.abs( window.pageYOffset - initialScrollPosition ) > 50 ) {
				accept();
			}
		};

		window.addEventListener( 'scroll ', scrollFunction );
	} else if ( overlay.classList.contains( 'hide-on-time ' ) ) {
		var timeout = parseInt( overlay.getAttribute( 'data-hide-timeout ' ), 10 ) || 0;
		setTimeout( accept, timeout * 1000 );
	}

	var accepted = false;
	function accept( event ) {
		if ( accepted ) {
			return;
		}
		accepted = true;

		if ( event && event.preventDefault ) {
			event.preventDefault();
		}

		if ( overlay.classList.contains( 'hide-on-scroll ' ) ) {
			window.removeEventListener( 'scroll ', scrollFunction );
		}

		var expireTime = new Date();
		var consentExpiration = parseInt( overlay.getAttribute( 'data-consent-expiration ' ), 10 ) || 0;
		expireTime.setTime( expireTime.getTime() + ( consentExpiration * 24 * 60 * 60 * 1000 ) );

		document.cookie = 'eucookielaw=' + expireTime.getTime() + ' ;path=/;expires=' + expireTime.toGMTString();
		if ( overlay.classList.contains( ' ads-active ' ) && overlay.classList.contains( 'hide-on-button ' ) ) {
			document.cookie = 'personalized-ads-consent=' + expireTime.getTime() + ' ;path=/;expires=' + expireTime.toGMTString();
		}

		fade( overlay, ' out ', function() {
			removeOverlay();
			remove( container );
		} );
	}
} )();
;
/*! This file is auto-generated */
!function(e,t){if("function"==typeof define&&define.amd)define("hoverintent",["module"],t);else if("undefined"!=typeof exports)t(module);else{var n={exports:{}};t(n),e.hoverintent=n.exports}}(this,function(e){"use strict";var t=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var o in n)Object.prototype.hasOwnProperty.call(n,o)&&(e[o]=n[o])}return e};e.exports=function(e,n,o){function i(e,t){return y&&(y=clearTimeout(y)),b=0,p?void 0:o.call(e,t)}function r(e){m=e.clientX,d=e.clientY}function u(e,t){if(y&&(y=clearTimeout(y)),Math.abs(h-m)+Math.abs(E-d)<x.sensitivity)return b=1,p?void 0:n.call(e,t);h=m,E=d,y=setTimeout(function(){u(e,t)},x.interval)}function s(t){return L=!0,y&&(y=clearTimeout(y)),e.removeEventListener("mousemove",r,!1),1!==b&&(h=t.clientX,E=t.clientY,e.addEventListener("mousemove",r,!1),y=setTimeout(function(){u(e,t)},x.interval)),this}function c(t){return L=!1,y&&(y=clearTimeout(y)),e.removeEventListener("mousemove",r,!1),1===b&&(y=setTimeout(function(){i(e,t)},x.timeout)),this}function v(t){L||(p=!0,n.call(e,t))}function a(t){!L&&p&&(p=!1,o.call(e,t))}function f(){e.addEventListener("focus",v,!1),e.addEventListener("blur",a,!1)}function l(){e.removeEventListener("focus",v,!1),e.removeEventListener("blur",a,!1)}var m,d,h,E,L=!1,p=!1,T={},b=0,y=0,x={sensitivity:7,interval:100,timeout:0,handleFocus:!1};return T.options=function(e){var n=e.handleFocus!==x.handleFocus;return x=t({},x,e),n&&(x.handleFocus?f():l()),T},T.remove=function(){e&&(e.removeEventListener("mouseover",s,!1),e.removeEventListener("mouseout",c,!1),l())},e&&(e.addEventListener("mouseover",s,!1),e.addEventListener("mouseout",c,!1)),T}});
;
/*! This file is auto-generated */
!function(l,u,d){function m(e){27===e.which&&(e=w(e.target,".menupop"))&&(e.querySelector(".menupop > .ab-item").focus(),y(e,"hover"))}function f(e){var t;13!==e.which||w(e.target,".ab-sub-wrapper")||(t=w(e.target,".menupop"))&&(e.preventDefault(),(o(t,"hover")?y:b)(t,"hover"))}function p(e){var t;13===e.which&&(t=e.target.getAttribute("href"),-1<d.userAgent.toLowerCase().indexOf("applewebkit"))&&t&&"#"===t.charAt(0)&&setTimeout(function(){var e=l.getElementById(t.replace("#",""));e&&(e.setAttribute("tabIndex","0"),e.focus())},100)}function h(e,t){!w(t.target,".ab-sub-wrapper")&&(t.preventDefault(),t=w(t.target,".menupop"))&&(o(t,"hover")?y:(E(e),b))(t,"hover")}function v(e){var t,n=e.target.parentNode;if(t=n?n.querySelector(".shortlink-input"):t)return e.preventDefault&&e.preventDefault(),e.returnValue=!1,b(n,"selected"),t.focus(),t.select(),!(t.onblur=function(){y(n,"selected")})}function g(){if("sessionStorage"in u)try{for(var e in sessionStorage)-1<e.indexOf("wp-autosave-")&&sessionStorage.removeItem(e)}catch(e){}}function o(e,t){return e&&(e.classList&&e.classList.contains?e.classList.contains(t):e.className&&-1<e.className.split(" ").indexOf(t))}function b(e,t){e&&(e.classList&&e.classList.add?e.classList.add(t):o(e,t)||(e.className&&(e.className+=" "),e.className+=t))}function y(e,t){var n,r;if(e&&o(e,t))if(e.classList&&e.classList.remove)e.classList.remove(t);else{for(n=" "+t+" ",r=" "+e.className+" ";-1<r.indexOf(n);)r=r.replace(n,"");e.className=r.replace(/^[\s]+|[\s]+$/g,"")}}function E(e){if(e&&e.length)for(var t=0;t<e.length;t++)y(e[t],"hover")}function L(e){if(!e.target||"wpadminbar"===e.target.id||"wp-admin-bar-top-secondary"===e.target.id)try{u.scrollTo({top:-32,left:0,behavior:"smooth"})}catch(e){u.scrollTo(0,-32)}}function w(e,t){for(u.Element.prototype.matches||(u.Element.prototype.matches=u.Element.prototype.matchesSelector||u.Element.prototype.mozMatchesSelector||u.Element.prototype.msMatchesSelector||u.Element.prototype.oMatchesSelector||u.Element.prototype.webkitMatchesSelector||function(e){for(var t=(this.document||this.ownerDocument).querySelectorAll(e),n=t.length;0<=--n&&t.item(n)!==this;);return-1<n});e&&e!==l;e=e.parentNode)if(e.matches(t))return e;return null}l.addEventListener("DOMContentLoaded",function(){var n,e,t,r,o,a,s,i,c=l.getElementById("wpadminbar");if(c&&"querySelectorAll"in c){n=c.querySelectorAll("li.menupop"),e=c.querySelectorAll(".ab-item"),t=l.getElementById("wp-admin-bar-logout"),r=l.getElementById("adminbarsearch"),o=l.getElementById("wp-admin-bar-get-shortlink"),a=c.querySelector(".screen-reader-shortcut"),s=/Mobile\/.+Safari/.test(d.userAgent)?"touchstart":"click",y(c,"nojs"),"ontouchstart"in u&&(l.body.addEventListener(s,function(e){w(e.target,"li.menupop")||E(n)}),c.addEventListener("touchstart",function e(){for(var t=0;t<n.length;t++)n[t].addEventListener("click",h.bind(null,n));c.removeEventListener("touchstart",e)})),c.addEventListener("click",L);for(i=0;i<n.length;i++)u.hoverintent(n[i],b.bind(null,n[i],"hover"),y.bind(null,n[i],"hover")).options({timeout:180}),n[i].addEventListener("keydown",f);for(i=0;i<e.length;i++)e[i].addEventListener("keydown",m);r&&((s=l.getElementById("adminbar-search")).addEventListener("focus",function(){b(r,"adminbar-focused")}),s.addEventListener("blur",function(){y(r,"adminbar-focused")})),a&&a.addEventListener("keydown",p),o&&o.addEventListener("click",v),u.location.hash&&u.scrollBy(0,-32),t&&t.addEventListener("click",g)}})}(document,window,navigator);;
// Handle adminbar menupop items.
( function () {
	'use strict ';

	function init() {
		document.querySelectorAll( 'li.menupop ' ).forEach( ( menuItem ) => {
			menuItem.addEventListener( 'touchstart ', ( e ) => {
				const target = e.target.closest( 'li ' );
				if (
					target.classList.contains( 'menupop ' ) &&
					target.getAttribute( 'id ' ) !== 'wp-admin-bar-switch-site '
				) {
					e.preventDefault();
					document.querySelectorAll( 'li.menupop ' ).forEach( ( li ) => {
						if ( li !== menuItem ) {
							li.classList.remove( 'hover ' );
						}
					} );
					menuItem.classList.toggle( 'hover ' );
				}
			} );
		} );
	}

	if ( document.readyState !== 'loading ' ) {
		init();
	} else {
		document.addEventListener( 'DOMContentLoaded ', init );
	}
} )();
;
/**
 * Comment Likes - JavaScript
 *
 * This handles liking and unliking comments, as well as viewing who has
 * liked a particular comment.
 *
 * @dependency  Swipe (dynamically loaded when needed)
 *
 * @package     Comment_Likes
 * @subpackage  JavaScript
 */
(function () {
	function init() {
		let extWin;
		let extWinCheck;
		let commentLikeEvent;

		// Only run once.
		if (window.comment_likes_loaded) {
			return;
		}
		window.comment_likes_loaded = true;

		// Client-side cache of who liked a particular comment to avoid
		// having to hit the server multiple times for the same data.
		const commentLikeCache = {};

		let swipeLibPromise;

		// Load the Swipe library, if it's not already loaded. function swipeLibLoader() { if (!swipeLibPromise) { swipeLibPromise=n ew Promise((resolve, reject)=> { if (window.Swipe) { resolve(window.Swipe); } else { const swipeScript = document.createElement('script'); swipeScript.src = comment_like_text.swipeUrl; swipeScript.async = true; document.body.appendChild(swipeScript); swipeScript.addEventListener('load',
                    () => resolve(window.Swipe)); swipeScript.addEventListener('error', error => reject(error)); } }); } return swipeLibPromise; } /** * Parse the comment ID from a comment like link. */ function getCommentId(link) { const commentId =
                    link && link.getAttribute('href') && link.getAttribute('href').split('like_comment='); return commentId[1].split('&_wpnonce=')[0]; } /** * Handle an ajax action on the comment like link. */ function handleLinkAction(link, action, commentId,
                    callback) { const nonce = link && link.getAttribute('href') && link.getAttribute('href').split('_wpnonce=')[1]; fetch('/wp-admin/admin-ajax.php', { method: 'POST', body: new URLSearchParams({ action: action, _wpnonce: nonce, like_comment:
                    commentId, blog_id: Number(link.dataset.blog), }), headers: { 'Content-Type': 'application/x-www-form-urlencoded; charset=UTF-8', 'X-Requested-With': 'XMLHttpRequest', Accept: 'application/json', 'cache-control': 'no-cache', pragma:
                    'no-cache', }, }) .then(response => response.json()) .then(callback); } function startPolling() { // Append cookie polling login iframe to this window to wait for user to finish logging in (or cancel) const loginIframe = document.createElement('iframe');
                    loginIframe.id = 'wp-login-polling-iframe'; loginIframe.src = 'https://wordpress.com/public.api/connect/?iframe=true'; document.body.appendChild(loginIframe); loginIframe.style.display = 'none'; } function stopPolling() { const iframe
                    = document.querySelector('#wp-login-polling-iframe'); if (iframe) { iframe.remove(); } } function hide(el) { if (el && el.style) { el.style.display = 'none'; } } function show(el) { if (el && el.style) { el.style.removeProperty('display');
                    } } // Overlay used for displaying comment like info. class Overlay { constructor() { // Overlay element. this.el = document.createElement('div'); this.el.classList.add('comment-likes-overlay'); document.body.appendChild(this.el);
                    hide(this.el); this.el.addEventListener('mouseenter', () => { // Don't hide the overlay if the user is mousing over it. overlay.cancelHide(); }); this.el.addEventListener('mouseleave', () => overlay.requestHide()); // Inner contents
                    of overlay. this.innerEl = null; // Instance of the Swipe library. this.swipe = null; // Timeout used for hiding the overlay. this.hideTimeout = null; } // Initialise the overlay for use, removing any old content. clear() { // Unload
                    any previous instance of Swipe (to avoid leaking a global // event handler). This is done before clearing the contents of the // overlay because Swipe expects the slides to still be present. if (this.swipe) { this.swipe.kill(); this.swipe
                    = null; } this.el.innerHTML = ''; this.innerEl = document.createElement('div'); this.innerEl.classList.add('inner'); this.el.appendChild(this.innerEl); } /** * Construct a list (
                    <ul>) of user (gravatar, name) details. * * @param data liker data returned from the server * @param klass CSS class to apply to the
                        <ul> element * @param start index of user to start at * @param length number of users to include in the list * * @return A container element with the list */ getUserBits(data, klass, start, length) { start = start || 0; let last = start
                            + (length || data.length); last = last > data.length ? data.length : last; const container = document.createElement('div'); container.classList.add('liker-list'); let html = `
                            <ul class="${klass || ''}">`; for (let i = start; i
                                < last; ++i) { const user=d ata[i]; html +=` <li>
                                    <a rel="nofollow" title="${user.display_name_esc}" href="${user.profile_url_esc}">
								<img src="${user.avatar_url_esc}" alt="${user.display_name_esc}" />
								<span class="user-name">${user.display_name_esc}</span>
							</a>
                                    </li>
                                    `; } html += '</ul>'; container.innerHTML = html; return container; } /** * Render the display of who has liked this comment. The type of * display depends on how many people have liked the comment. * If more than 10
                            people have liked the comment, this function * renders navigation controls and sets up the Swipe library for * changing between pages. * * @param link the element over which the user is hovering * @param data the results retrieved
                            from the server */ showLikes(link, data) { this.clear(); link.dataset.likeCount = data.length; if (data.length === 0) { // No likers after all. hide(this.el); return; } this.innerEl.style.padding = '12px'; if (data.length
                            <
                                6) { // Only one column needed. this.innerEl.style.maxWidth='200px' ; this.innerEl.innerHTML='' ; this.innerEl.appendChild(this.getUserBits(data, 'single')); this.setPosition(link); } else if (data.length < 11) { // Two columns,
                                but only one page. this.innerEl.innerHTML='' ; this.innerEl.appendChild(this.getUserBits(data, 'double')); this.setPosition(link); } else { // Multiple pages. this.renderLikesWithPagination(data, link); } } /** * Render multiple
                                pages of likes with pagination controls. * This function is intended to be called by `showLikes` above. * * @param data the results retrieved from the server */ renderLikesWithPagination(data, link) { swipeLibLoader().then(()=>
                            { const page_count = Math.ceil(data.length / 10); // Swipe requires two nested containers. const swipe = document.createElement('div'); swipe.classList.add('swipe'); this.innerEl.appendChild(swipe); const wrap = document.createElement('div');
                                wrap.classList.add('swipe-wrap'); swipe.appendChild(wrap); for (let i = 0; i
                                < page_count; ++i) { wrap.appendChild(this.getUserBits(data, 'double', i * 10, 10)); } /** * Navigation controls. * This is based on the Newdash
                                    controls found in * reader/recommendations-templates.php */ const nav=d ocument.createElement( 'nav'); nav.classList.add( 'slider-nav'); let navContents=` <a href="#" class="prev">
                                    <span class="noticon noticon-previous" title="Previous" alt="<"></span>
                                    </a>
                                    <span class="position">
					`;
					for (let i = 0; i < page_count; ++i) {
						navContents += `<em data-page="${i}" class="${i === 0 ? 'on' : ''}">&bull;</em>`;
					}
					navContents += `
						</span>
                                    <a href="#" class="next">
							<span class="noticon noticon-next" title="Next" alt=">"></span>
						</a> `; this.innerEl.appendChild(nav); nav.innerHTML = navContents; /** Set up Swipe. **/ // Swipe cannot be set up successfully unless its container // is visible, so we show it now. show(this.el); this.setPosition(link);
                                    this.swipe = new Swipe(swipe, { callback: function (pos) { // Update the pagination indicators. // // If there are exactly two pages, Swipe has a weird // special case where it duplicates both pages and // can return
                                    index 2 and 3 even though those aren't // real pages (see swipe.js, line 47). To deal with // this, we use the expression `pos % page_count`. pos = pos % page_count; nav.querySelectorAll('em').forEach(em => { const
                                    page = Number(em.dataset.page); em.setAttribute('class', pos === page ? 'on' : ''); }); }, }); nav.querySelectorAll('em').forEach(em => { em.addEventListener('click', e => { // Go to the page corresponding to the indicator
                                    clicked. this.swipe.slide(Number(em.dataset.page)); e.preventDefault(); }); }); // Previous and next buttons. nav.querySelector('.prev').addEventListener('click', e => { this.swipe.prev(); e.preventDefault(); }); nav.querySelector('.next').addEventListener('click',
                                    e => { this.swipe.next(); e.preventDefault(); }); }); } /** * Open the overlay and show a loading message. */ showLoadingMessage(link) { this.clear(); this.innerEl.textContent = comment_like_text.loading; this.setPosition(link);
                                    } /** * Position the overlay near the current comment. * * @param link element near which to position the overlay */ setPosition(link) { // Prepare a down arrow icon for the bottom of the overlay. const icon = document.createElement('span');
                                    this.el.appendChild(icon); icon.classList.add('icon', 'noticon', 'noticon-downarrow'); icon.style.textShadow = '0px 1px 1px rgb(223, 223, 223)'; const rect = link.getBoundingClientRect(); const win = document.defaultView;
                                    const offset = { top: rect.top + win.scrollY, left: rect.left + win.scrollX, }; // Take measurements with the element fully visible. show(this.el); let left = offset.left - (this.el.offsetWidth - link.offsetWidth) /
                                    2; left = left
                                    < 5 ? 5 : left; let top=o ffset.top - this.el.offsetHeight + 5; hide(this.el); const adminBar=d ocument.querySelector( '#wpadminbar'); // Check if the overlay would appear off the screen. if (top < win.scrollY
                                        + ((adminBar && adminBar.offsetHeight) || 0)) { // We 'll display the overlay beneath the link instead.
					top = offset.top + link.offsetHeight;
					// Instead of using the down arrow icon, use an up arrow.
					icon.remove();
					this.el.prepend(icon);
					icon.classList.remove('noticon-downarrow ');
					icon.classList.add('noticon-uparrow ');
					icon.style.textShadow = '0px -1px 1px rgb(223, 223, 223) ';
					icon.style.verticalAlign = 'bottom ';
				}

				this.el.style.left = `${left}px`;
				this.el.style.top = `${top}px`;
				show(this.el);

				// The height of the arrow icon differs slightly between browsers,
				// so we compute the margin here to make sure it isn't disjointed // from the overlay. icon.style.marginTop=` ${icon.scrollHeight - 26}px`; icon.style.marginBottom=` ${20 - icon.scrollHeight}px`; // Position the arrow to be horizontally centred
                                        on the link. icon.style.paddingLeft=` ${ offset.left - left + (link.offsetWidth - icon.scrollWidth) / 2 }px`; } /** * Return whether the overlay is visible. */ isVisible() { return this.el.style.getPropertyValue(
                                        'display') !=='none' ; } /** * Request that the overlay be hidden after a short delay. */ requestHide() { if (this.hideTimeout !==n ull) { return; } this.hideTimeout=s etTimeout(()=> { hide(this.el); this.clear(); }, 300); } /** * Cancel a request to hide the overlay. */ cancelHide() { if (this.hideTimeout !== null) { clearTimeout(this.hideTimeout); this.hideTimeout = null; } } } // Overlay used
                                        for displaying comment like info. const overlay = new Overlay(); // The most recent comment for which the user has requested to see // who liked it. var relevantComment; // Precache after this timeout. var precacheTimeout
                                        = null; /** * Fetch the like data for a particular comment. */ function fetchLikeData(link, commentId) { commentLikeCache[commentId] = null; const container = link && link.parentElement && link.parentElement.parentElement;
                                        const star = container.querySelector('a.comment-like-link'); star && handleLinkAction(star, 'view_comment_likes', commentId, data => { // Populate the cache. commentLikeCache[commentId] = data; // Only show the
                                        overlay if the user is interested. if (overlay.isVisible() && relevantComment === commentId) { overlay.showLikes(link, data); } }); } function readCookie(c) { const nameEQ = c + '='; const cookieStrings = document.cookie.split(';');
                                        for (let i = 0; i
                                        < cookieStrings.length; i++) { let cookieString=c ookieStrings[i]; while (cookieString.charAt(0)===' ' ) { cookieString=c ookieString.substring(1, cookieString.length); } if (cookieString.indexOf(nameEQ)===0
                                            ) { const chunk=c ookieString.substring(nameEQ.length, cookieString.length); const pairs=c hunk.split( '&'); const cookieData={ }; for (let num=p airs.length - 1; num>= 0; num--) { const pair = pairs[num].split('='); cookieData[pair[0]] = decodeURIComponent(pair[1]); } return cookieData; } } return null; } function getServiceData() { const data = readCookie('wpc_wpc'); if (data
                                            === null || typeof data.access_token === 'undefined' || !data.access_token) { return false; } return data; } function readMessage(msg) { const event = msg.data; if (typeof event.event === 'undefined') { return;
                                            } if (event.event === 'login' && event.success) { extWinCheck = setInterval(function () { if (!extWin || extWin.closed) { clearInterval(extWinCheck); if (getServiceData()) { // Load page in an iframe to get
                                            the current comment nonce const nonceIframe = document.createElement('iframe'); nonceIframe.id = 'wp-login-comment-nonce-iframe'; nonceIframe.style.display = 'none'; nonceIframe.src = commentLikeEvent + '';
                                            document.body.appendChild(nonceIframe); const commentLikeId = (commentLikeEvent + '') .split('like_comment=')[1] .split('&_wpnonce=')[0]; let c; // Set a 5 second timeout to redirect to the comment page without
                                            doing the Like as a fallback const commentLikeTimeout = setTimeout(() => { window.location = commentLikeEvent; }, 5000); // Check for a new nonced redirect and use that if available before timing out const commentLikeCheck
                                            = setInterval(() => { const iframe = document.querySelector('#wp-login-comment-nonce-iframe'); if (iframe) { c = iframe.querySelector(`#comment-like-${commentLikeId} .comment-like-link`); } if (c && typeof c.href
                                            !== 'undefined') { clearTimeout(commentLikeTimeout); clearInterval(commentLikeCheck); window.location = c.href; } }, 100); } } }, 100); if (extWin) { if (!extWin.closed) { extWin.close(); } extWin = false; }
                                            stopPolling(); } } if (typeof window.postMessage !== 'undefined') { window.addEventListener('message', e => { let message = e && e.data; if (typeof message === 'string') { try { message = JSON.parse(message);
                                            } catch (err) { return; } } const type = message && message.type; if (type === 'loginMessage') { readMessage(message); } }); } document.body.addEventListener('click', e => { let target = e.target; // Don't do
                                            anything when clicking on the "X people" link. if (target.matches('p.comment-likes a.view-likers')) { e.preventDefault(); return; } // Retrieve the surrounding paragraph to the star, if it hasn't been liked.
                                            const notLikedPar = target.closest('p.comment-not-liked'); // Return if not clicking on star or surrounding paragraph. if (!target.matches('a.comment-like-link') && !notLikedPar) { return; } // When a comment
                                            hasn't been liked, make the text clickable, too. if (notLikedPar) { target = notLikedPar.querySelector('a.comment-like-link'); if (!target) { return; } } if (target.classList.contains('needs-login')) { e.preventDefault();
                                            commentLikeEvent = target; if (extWin) { if (!extWin.closed) { extWin.close(); } extWin = false; } stopPolling(); const url = 'https://wordpress.com/public.api/connect/?action=request&service=wordpress'; extWin
                                            = window.open( url, 'likeconn', 'status=0,toolbar=0,location=1,menubar=0,directories=0,resizable=1,scrollbars=1,height=560,width=500' ); startPolling(); return false; } // Record that the user likes or does
                                            not like this comment. const commentId = getCommentId(target); target.classList.add('loading'); let commentEl = document.querySelector(`p#comment-like-${commentId}`); // Determine whether to like or unlike based
                                            on whether the comment is // currently liked. const action = commentEl && commentEl.dataset.liked === 'comment-liked' ? 'unlike_comment' : 'like_comment'; handleLinkAction(target, action, commentId, data =>
                                            { // Invalidate the like cache for this comment. delete commentLikeCache[commentId]; const countEl = document.querySelector(`#comment-like-count-${data.context}`); if (countEl) { countEl.innerHTML = data.display;
                                            } commentEl = document.querySelector(`p#comment-like-${data.context}`); if (action === 'like_comment') { commentEl.classList.remove('comment-not-liked'); commentEl.classList.add('comment-liked'); commentEl.dataset.liked
                                            = 'comment-liked'; } else { commentEl.classList.remove('comment-liked'); commentEl.classList.add('comment-not-liked'); commentEl.dataset.liked = 'comment-not-liked'; } // Prefetch new data for this comment (if
                                            there are likers left). const parent = target.closest('.comment-likes'); const link = parent && parent.querySelector('a.view-likers'); if (link) { fetchLikeData(link, commentId); } target.classList.remove('loading');
                                            }); e.preventDefault(); e.stopPropagation(); }); document.body.addEventListener( 'mouseenter', function (e) { if (!e.target.matches('p.comment-likes a.view-likers')) { return; } // Show the user a list of who
                                            has liked this comment. const link = e.target; if (Number(link.dataset.likeCount || 0) === 0) { // No one has liked this comment. return; } // Don't hide the overlay. overlay.cancelHide(); // Get the comment
                                            ID. const container = link.parentElement && link.parentElement.parentElement; const star = container && container.querySelector('a.comment-like-link'); const commentId = star && getCommentId(star); relevantComment
                                            = commentId; // Check if the list of likes for this comment is already in // the cache. if (commentId in commentLikeCache) { const entry = commentLikeCache[commentId]; // Only display the likes if the ajax request
                                            is // actually done. if (entry !== null) { overlay.showLikes(link, entry); } else { // Make sure the overlay is visible (in case // the user moved the mouse away while loading // but then came back before it
                                            finished // loading). overlay.showLoadingMessage(link); } return; } // Position the "Loading..." overlay. overlay.showLoadingMessage(link); // Fetch the data. fetchLikeData(link, commentId); }, true ); document.body.addEventListener(
                                            'mouseleave', e => { if (!e.target.matches('p.comment-likes a.view-likers')) { return; } // User has moved cursor away - hide the overlay. overlay.requestHide(); }, true ); document.body.addEventListener( 'mouseenter',
                                            e => { if (!e.target.matches('.comment') || !e.target.querySelector('a.comment-like-link')) { return; } // User is moving over a comment - precache the comment like data. if (precacheTimeout !== null) { clearTimeout(precacheTimeout);
                                            precacheTimeout = null; } const star = e.target.querySelector('a.comment-like-link'); const parent = star.closest('.comment-likes'); const link = parent && parent.querySelector('a.view-likers'); if (!link ||
                                            Number(link.dataset.likeCount || 0) === 0) { // No likes. return; } const commentId = getCommentId(star); if (commentId in commentLikeCache) { // Already in cache. return; } precacheTimeout = setTimeout(() =>
                                            { precacheTimeout = null; if (commentId in commentLikeCache) { // Was cached in the interim. return; } fetchLikeData(link, commentId); }, 1000); }, true ); } if (document.readyState !== 'loading') { init();
                                            } else { document.addEventListener('DOMContentLoaded', init); } })(); ; (function() { /** * Debounce * * @param {Function} func * @param {number} wait * @param {boolean} immediate */ function debounce(func,
                                            wait, immediate) { 'use strict'; var timeout; wait = (typeof wait !== 'undefined') ? wait : 20; immediate = (typeof immediate !== 'undefined') ? immediate : true; return function() { var context = this, args
                                            = arguments; var later = function() { timeout = null; if (!immediate) { func.apply(context, args); } }; var callNow = immediate && !timeout; clearTimeout(timeout); timeout = setTimeout(later, wait); if (callNow)
                                            { func.apply(context, args); } }; } /** * Get page header height and use it for top-margin on * site-content when above mobile breakpoint */ function pageHeaderHeight() { var body = document.body; if ( document.documentElement.clientWidth
                                            <=6 40 ) { document.getElementById( "primary" ).style.marginTop=0 ; body.classList.remove( 'wp-sticky-header' ); } else { var header=d ocument.getElementById( 'masthead' ); var content=d ocument.getElementById(
                                                'primary' ); var headerOffsetHeight=0 ; if ( header ) { headerOffsetHeight=h eader.offsetHeight; content.style.marginTop=h eaderOffsetHeight + "px"; } if ( document.documentElement.clientHeight / 5 - headerOffsetHeight>= 0 ) { body.classList.add( 'wp-sticky-header' ); } else { body.classList.remove( 'wp-sticky-header' ); } } }; /** * Run our function every time the window resizes */ var isResizing = false; window.addEventListener(
                                                'resize', debounce( function() { if ( isResizing ) { return; } isResizing = true; setTimeout( function() { pageHeaderHeight(); isResizing = false; }, 150 ); } ) ); /** * Run our page header height function
                                                */ window.addEventListener( 'load', pageHeaderHeight ); pageHeaderHeight(); })(); ; /* globals JSON */ ( function () { var eventName = 'wpcom_masterbar_click'; var linksTracksEvents = { // top level items
                                                'wp-admin-bar-blog' : 'my_sites', 'wp-admin-bar-newdash' : 'reader', 'wp-admin-bar-ab-new-post' : 'write_button', 'wp-admin-bar-my-account' : 'my_account', 'wp-admin-bar-notes' : 'notifications', // my sites
                                                - top items 'wp-admin-bar-switch-site' : 'my_sites_switch_site', 'wp-admin-bar-blog-info' : 'my_sites_site_info', 'wp-admin-bar-site-view' : 'my_sites_view_site', 'wp-admin-bar-blog-stats' : 'my_sites_site_stats',
                                                'wp-admin-bar-plan' : 'my_sites_plan', 'wp-admin-bar-plan-badge' : 'my_sites_plan_badge', // my sites - manage 'wp-admin-bar-edit-page' : 'my_sites_manage_site_pages', 'wp-admin-bar-new-page-badge' : 'my_sites_manage_add_page',
                                                'wp-admin-bar-edit-post' : 'my_sites_manage_blog_posts', 'wp-admin-bar-new-post-badge' : 'my_sites_manage_add_post', 'wp-admin-bar-edit-attachment' : 'my_sites_manage_media', 'wp-admin-bar-new-attachment-badge'
                                                : 'my_sites_manage_add_media', 'wp-admin-bar-comments' : 'my_sites_manage_comments', 'wp-admin-bar-edit-jetpack-testimonial' : 'my_sites_manage_testimonials', 'wp-admin-bar-new-jetpack-testimonial' : 'my_sites_manage_add_testimonial',
                                                'wp-admin-bar-edit-jetpack-portfolio' : 'my_sites_manage_portfolio', 'wp-admin-bar-new-jetpack-portfolio' : 'my_sites_manage_add_portfolio', // my sites - personalize 'wp-admin-bar-themes' : 'my_sites_personalize_themes',
                                                'wp-admin-bar-cmz' : 'my_sites_personalize_themes_customize', // my sites - configure 'wp-admin-bar-sharing' : 'my_sites_configure_sharing', 'wp-admin-bar-people' : 'my_sites_configure_people', 'wp-admin-bar-people-add'
                                                : 'my_sites_configure_people_add_button', 'wp-admin-bar-plugins' : 'my_sites_configure_plugins', 'wp-admin-bar-domains' : 'my_sites_configure_domains', 'wp-admin-bar-domains-add' : 'my_sites_configure_add_domain',
                                                'wp-admin-bar-blog-settings' : 'my_sites_configure_settings', 'wp-admin-bar-legacy-dashboard' : 'my_sites_configure_wp_admin', // reader 'wp-admin-bar-followed-sites' : 'reader_followed_sites', 'wp-admin-bar-reader-followed-sites-manage':
                                                'reader_manage_followed_sites', 'wp-admin-bar-discover-discover' : 'reader_discover', 'wp-admin-bar-discover-search' : 'reader_search', 'wp-admin-bar-my-activity-my-likes' : 'reader_my_likes', // account
                                                'wp-admin-bar-user-info' : 'my_account_user_name', // account - profile 'wp-admin-bar-my-profile' : 'my_account_profile_my_profile', 'wp-admin-bar-account-settings' : 'my_account_profile_account_settings',
                                                'wp-admin-bar-billing' : 'my_account_profile_manage_purchases', 'wp-admin-bar-security' : 'my_account_profile_security', 'wp-admin-bar-notifications' : 'my_account_profile_notifications', // account - special
                                                'wp-admin-bar-get-apps' : 'my_account_special_get_apps', 'wp-admin-bar-next-steps' : 'my_account_special_next_steps', 'wp-admin-bar-help' : 'my_account_special_help', }; var notesTracksEvents = { openSite:
                                                function ( data ) { return { clicked: 'masterbar_notifications_panel_site', site_id: data.siteId }; }, openPost: function ( data ) { return { clicked: 'masterbar_notifications_panel_post', site_id: data.siteId,
                                                post_id: data.postId }; }, openComment: function ( data ) { return { clicked: 'masterbar_notifications_panel_comment', site_id: data.siteId, post_id: data.postId, comment_id: data.commentId }; } }; // Element.prototype.matches
                                                as a standalone function, with old browser fallback function matches( node, selector ) { if ( ! node ) { return undefined; } if ( ! Element.prototype.matches && ! Element.prototype.msMatchesSelector ) {
                                                throw new Error( 'Unsupported browser' ); } return Element.prototype.matches ? node.matches( selector ) : node.msMatchesSelector( selector ); } // Element.prototype.closest as a standalone function, with
                                                old browser fallback function closest( node, selector ) { if ( ! node ) { return undefined; } if ( Element.prototype.closest ) { return node.closest( selector ); } do { if ( matches( node, selector ) ) {
                                                return node; } node = node.parentElement || node.parentNode; } while ( node !== null && node.nodeType === 1 ); return null; } function recordTracksEvent( eventProps ) { eventProps = eventProps || {}; window._tkq
                                                = window._tkq || []; window._tkq.push( [ 'recordEvent', eventName, eventProps ] ); } function parseJson( s, defaultValue ) { try { return JSON.parse( s ); } catch ( e ) { return defaultValue; } } function
                                                createTrackableLinkEventHandler( link ) { return function () { var parent = closest( link, 'li' ); if ( ! parent ) { return; } var trackingId = link.getAttribute( 'ID' ) || parent.getAttribute( 'ID' ); if
                                                ( ! linksTracksEvents.hasOwnProperty( trackingId ) ) { return; } var eventProps = { 'clicked': linksTracksEvents[ trackingId ] }; recordTracksEvent( eventProps ); } } function init() { var trackableLinkSelector
                                                = '.mb-trackable .ab-item:not(div),' + '#wp-admin-bar-notes .ab-item,' + '#wp-admin-bar-user-info .ab-item,' + '.mb-trackable .ab-secondary'; var trackableLinks = document.querySelectorAll( trackableLinkSelector
                                                ); for ( var i = 0; i
                                                < trackableLinks.length; i++ ) { var link=t rackableLinks[ i ]; var handler=c reateTrackableLinkEventHandler( link ); link.addEventListener( 'click', handler ); link.addEventListener(
                                                    'touchstart', handler ); } } if ( document.readyState==='loading' ) { document.addEventListener( 'DOMContentLoaded', init ); } else { init(); } // listen for postMessage events from the notifications iframe window.addEventListener(
                                                    'message', function ( event ) { if ( event.origin !=='https://widgets.wp.com' ) { return; } var data=( typeof event.data==='string' ) ? parseJson( event.data, {} ) : event.data; if ( data.type !=='notesIframeMessage'
                                                    ) { return; } var eventData=n otesTracksEvents[ data.action ]; if ( ! eventData ) { return; } recordTracksEvent( eventData( data ) ); }, false ); } )(); ; !function(e){ "object"==typeof exports&&
                                                    "undefined"!=typeof module|| "function"!=typeof define||!define.amd?e():define( "inert",e)}((function(){ "use strict";var e,t,n,i,o,r,s=function(e,t,n){return t&&a(e.prototype,t),n&&a(e,n),e};function a(e,t){for(var
                                                    n=0;n<t.length;n++){var i=t[n];i.enumerable=i.enumerable||!1,i.configurable=!0, "value"in i&&(i.writable=!0),Object.defineProperty(e,i.key,i)}}function d(e,t){if(!(e instanceof t))throw new TypeError(
                                                    "Cannot call a class as a function")}function u(e,t){d(this,u),this._inertManager=t,this._rootElement=e,this._managedNodes=new Set,this._rootElement.hasAttribute( "aria-hidden")?this._savedAriaHidden=this._rootElement.getAttribute(
                                                    "aria-hidden"):this._savedAriaHidden=null,this._rootElement.setAttribute( "aria-hidden", "true"),this._makeSubtreeUnfocusable(this._rootElement),this._observer=new MutationObserver(this._onMutation.bind(this)),this._observer.observe(this._rootElement,{attributes:!0,childList:!0,subtree:!0})}function
                                                    h(e,t){d(this,h),this._node=e,this._overrodeFocusMethod=!1,this._inertRoots=new Set([t]),this._savedTabIndex=null,this._destroyed=!1,this.ensureUntabbable()}function l(e){if(d(this,l),!e)throw new Error(
                                                    "Missing required argument; InertManager needs to wrap a document.");this._document=e,this._managedNodes=new Map,this._inertRoots=new Map,this._observer=new MutationObserver(this._watchForInert.bind(this)),_(e.head||e.body||e.documentElement), "loading"===e.readyState?e.addEventListener(
                                                    "DOMContentLoaded",this._onDocumentLoaded.bind(this)):this._onDocumentLoaded()}function c(e,t,n){if(e.nodeType==Node.ELEMENT_NODE){var i=e;if(s=(t&&t(i),i.shadowRoot))return void c(s,t,s);if( "content"==i.localName){for(var
                                                    o=(s=i).getDistributedNodes?s.getDistributedNodes():[],r=0;r<o.length;r++)c(o[r],t,n);return}if( "slot"==i.localName){for(var s,a=(s=i).assignedNodes?s.assignedNodes({flatten:!0}):[],d=0;d<a.length;d++)c(a[d],t,n);return}}for(var
                                                    u=e.firstChild;null!=u;)c(u,t,n),u=u.nextSibling}function _(e){var t;e.querySelector( "style#inert-style, link#inert-style")||((t=document.createElement( "style")).setAttribute( "id", "inert-style"),t.textContent="\n[inert] {\n  pointer-events: none;\n  cursor: default;\n}\n\n[inert], [inert] * {\n  -webkit-user-select: none;\n  -moz-user-select: none;\n  -ms-user-select: none;\n  user-select: none;\n}\n"
                                                    ,e.appendChild(t))} "undefined"!=typeof window&&(e=Array.prototype.slice,t=Element.prototype.matches||Element.prototype.msMatchesSelector,n=[ "a[href]", "area[href]", "input:not([disabled])",
                                                    "select:not([disabled])", "textarea:not([disabled])", "button:not([disabled])", "details", "summary", "iframe", "object", "embed", "[contenteditable]"].join( ","),s(u,[{key: "destructor",value:function(){this._observer.disconnect(),this._rootElement&&(null!==this._savedAriaHidden?this._rootElement.setAttribute(
                                                    "aria-hidden",this._savedAriaHidden):this._rootElement.removeAttribute( "aria-hidden")),this._managedNodes.forEach((function(e){this._unmanageNode(e.node)}),this),this._observer=null,this._rootElement=null,this._managedNodes=null,this._inertManager=null}},{key:
                                                    "_makeSubtreeUnfocusable",value:function(e){var t=this,n=(c(e,(function(e){return t._visitNode(e)})),document.activeElement);if(!document.body.contains(e)){for(var i=e,o=void 0;i;){if(i.nodeType===Node.DOCUMENT_FRAGMENT_NODE){o=i;break}i=i.parentNode}o&&(n=o.activeElement)}e.contains(n)&&(n.blur(),n===document.activeElement&&document.body.focus())}},{key:
                                                    "_visitNode",value:function(e){e.nodeType===Node.ELEMENT_NODE&&(e!==this._rootElement&&e.hasAttribute( "inert")&&this._adoptInertRoot(e),(t.call(e,n)||e.hasAttribute( "tabindex"))&&this._manageNode(e))}},{key:
                                                    "_manageNode",value:function(e){e=this._inertManager.register(e,this),this._managedNodes.add(e)}},{key: "_unmanageNode",value:function(e){(e=this._inertManager.deregister(e,this))&&this._managedNodes.delete(e)}},{key:
                                                    "_unmanageSubtree",value:function(e){var t=this;c(e,(function(e){return t._unmanageNode(e)}))}},{key: "_adoptInertRoot",value:function(e){var t=this._inertManager.getInertRoot(e);t||(this._inertManager.setInert(e,!0),t=this._inertManager.getInertRoot(e)),t.managedNodes.forEach((function(e){this._manageNode(e.node)}),this)}},{key:
                                                    "_onMutation",value:function(t,n){t.forEach((function(t){var n,i=t.target; "childList"===t.type?(e.call(t.addedNodes).forEach((function(e){this._makeSubtreeUnfocusable(e)}),this),e.call(t.removedNodes).forEach((function(e){this._unmanageSubtree(e)}),this)):
                                                    "attributes"===t.type&&( "tabindex"===t.attributeName?this._manageNode(i):i!==this._rootElement&& "inert"===t.attributeName&&i.hasAttribute( "inert")&&(this._adoptInertRoot(i),n=this._inertManager.getInertRoot(i),this._managedNodes.forEach((function(e){i.contains(e.node)&&n._manageNode(e.node)}))))}),this)}},{key:
                                                    "managedNodes",get:function(){return new Set(this._managedNodes)}},{key: "hasSavedAriaHidden",get:function(){return null!==this._savedAriaHidden}},{key: "savedAriaHidden",set:function(e){this._savedAriaHidden=e},get:function(){return
                                                    this._savedAriaHidden}}]),i=u,s(h,[{key: "destructor",value:function(){var e;this._throwIfDestroyed(),this._node&&this._node.nodeType===Node.ELEMENT_NODE&&(e=this._node,null!==this._savedTabIndex?e.setAttribute(
                                                    "tabindex",this._savedTabIndex):e.removeAttribute( "tabindex"),this._overrodeFocusMethod&&delete e.focus),this._node=null,this._inertRoots=null,this._destroyed=!0}},{key: "_throwIfDestroyed",value:function(){if(this.destroyed)throw
                                                    new Error( "Trying to access destroyed InertNode")}},{key: "ensureUntabbable",value:function(){var e;this.node.nodeType===Node.ELEMENT_NODE&&(e=this.node,t.call(e,n)?-1===e.tabIndex&&this.hasSavedTabIndex||(e.hasAttribute(
                                                    "tabindex")&&(this._savedTabIndex=e.tabIndex),e.setAttribute( "tabindex", "-1"),e.nodeType===Node.ELEMENT_NODE&&(e.focus=function(){},this._overrodeFocusMethod=!0)):e.hasAttribute( "tabindex")&&(this._savedTabIndex=e.tabIndex,e.removeAttribute(
                                                    "tabindex")))}},{key: "addInertRoot",value:function(e){this._throwIfDestroyed(),this._inertRoots.add(e)}},{key: "removeInertRoot",value:function(e){this._throwIfDestroyed(),this._inertRoots.delete(e),0===this._inertRoots.size&&this.destructor()}},{key:
                                                    "destroyed",get:function(){return this._destroyed}},{key: "hasSavedTabIndex",get:function(){return null!==this._savedTabIndex}},{key: "node",get:function(){return this._throwIfDestroyed(),this._node}},{key:
                                                    "savedTabIndex",set:function(e){this._throwIfDestroyed(),this._savedTabIndex=e},get:function(){return this._throwIfDestroyed(),this._savedTabIndex}}]),o=h,s(l,[{key: "setInert",value:function(e,t){if(t){if(!this._inertRoots.has(e)&&(t=new
                                                    i(e,this),e.setAttribute( "inert", ""),this._inertRoots.set(e,t),!this._document.body.contains(e)))for(var n=e.parentNode;n;)11===n.nodeType&&_(n),n=n.parentNode}else this._inertRoots.has(e)&&(this._inertRoots.get(e).destructor(),this._inertRoots.delete(e),e.removeAttribute(
                                                    "inert"))}},{key: "getInertRoot",value:function(e){return this._inertRoots.get(e)}},{key: "register",value:function(e,t){var n=this._managedNodes.get(e);return void 0!==n?n.addInertRoot(t):n=new o(e,t),this._managedNodes.set(e,n),n}},{key:
                                                    "deregister",value:function(e,t){var n=this._managedNodes.get(e);return n?(n.removeInertRoot(t),n.destroyed&&this._managedNodes.delete(e),n):null}},{key: "_onDocumentLoaded",value:function(){e.call(this._document.querySelectorAll(
                                                    "[inert]")).forEach((function(e){this.setInert(e,!0)}),this),this._observer.observe(this._document.body||this._document.documentElement,{attributes:!0,subtree:!0,childList:!0})}},{key: "_watchForInert",value:function(n,i){var
                                                    o=this;n.forEach((function(n){switch(n.type){case "childList":e.call(n.addedNodes).forEach((function(n){var i;n.nodeType===Node.ELEMENT_NODE&&(i=e.call(n.querySelectorAll( "[inert]")),t.call(n, "[inert]")&&i.unshift(n),i.forEach((function(e){this.setInert(e,!0)}),o))}),o);break;case
                                                    "attributes":if( "inert"!==n.attributeName)return;var i=n.target,r=i.hasAttribute( "inert");o.setInert(i,r)}}),this)}}]),s=l,HTMLElement.prototype.hasOwnProperty( "inert")||(r=new s(document),Object.defineProperty(HTMLElement.prototype,
                                                    "inert",{enumerable:!0,get:function(){return this.hasAttribute( "inert")},set:function(e){r.setInert(this,e)}})))})); ; var runtime=function(t){ "use strict";var r,e=Object.prototype,n=e.hasOwnProperty,o=Object.defineProperty||function(t,r,e){t[r]=e.value},i=(w="function"==typeof
                                                    Symbol?Symbol:{}).iterator|| "@@iterator",a=w.asyncIterator|| "@@asyncIterator",c=w.toStringTag|| "@@toStringTag";function u(t,r,e){return Object.defineProperty(t,r,{value:e,enumerable:!0,configurable:!0,writable:!0}),t[r]}try{u({},
                                                    "")}catch(e){u=function(t,r,e){return t[r]=e}}function h(t,e,n,i){var a,c,u,h;e=e&&e.prototype instanceof v?e:v,e=Object.create(e.prototype),i=new O(i||[]);return o(e, "_invoke",{value:(a=t,c=n,u=i,h=f,function(t,e){if(h===p)throw
                                                    new Error( "Generator is already running");if(h===y){if( "throw"===t)throw e;return G()}for(u.method=t,u.arg=e;;){var n=u.delegate;if(n&&(n=function t(e,n){var o=n.method,i=e.iterator[o];return i===r?(n.delegate=null,
                                                    "throw"===o&&e.iterator.return&&(n.method="return" ,n.arg=r,t(e,n), "throw"===n.method)|| "return"!==o&&(n.method="throw" ,n.arg=new TypeError( "The iterator does not provide a '"+o+ "' method")),g): "throw"===(o=l(i,e.iterator,n.arg)).type?(n.method="throw"
                                                    ,n.arg=o.arg,n.delegate=null,g):(i=o.arg)?i.done?(n[e.resultName]=i.value,n.next=e.nextLoc, "return"!==n.method&&(n.method="next" ,n.arg=r),n.delegate=null,g):i:(n.method="throw" ,n.arg=new TypeError(
                                                    "iterator result is not an object"),n.delegate=null,g)}(n,u),n)){if(n===g)continue;return n}if( "next"===u.method)u.sent=u._sent=u.arg;else if( "throw"===u.method){if(h===f)throw h=y,u.arg;u.dispatchException(u.arg)}else "return"===u.method&&u.abrupt(
                                                    "return",u.arg);if(h=p, "normal"===(n=l(a,c,u)).type){if(h=u.done?y:s,n.arg!==g)return{value:n.arg,done:u.done}}else "throw"===n.type&&(h=y,u.method="throw" ,u.arg=n.arg)}})}),e}function l(t,r,e){try{return{type:
                                                    "normal",arg:t.call(r,e)}}catch(t){return{type: "throw",arg:t}}}t.wrap=h;var f="suspendedStart" ,s="suspendedYield" ,p="executing" ,y="completed" ,g={};function v(){}function d(){}function m(){}var w,b,L=((b=(b=(u(w={},i,(function(){return
                                                    this})),Object.getPrototypeOf))&&b(b(k([]))))&&b!==e&&n.call(b,i)&&(w=b),m.prototype=v.prototype=Object.create(w));function x(t){[ "next", "throw", "return"].forEach((function(r){u(t,r,(function(t){return
                                                    this._invoke(r,t)}))}))}function E(t,r){var e;o(this, "_invoke",{value:function(o,i){function a(){return new r((function(e,a){!function e(o,i,a,c){var u;if( "throw"!==(o=l(t[o],t,i)).type)return(i=(u=o.arg).value)&&
                                                    "object"==typeof i&&n.call(i, "__await")?r.resolve(i.__await).then((function(t){e( "next",t,a,c)}),(function(t){e( "throw",t,a,c)})):r.resolve(i).then((function(t){u.value=t,a(u)}),(function(t){return e(
                                                    "throw",t,a,c)}));c(o.arg)}(o,i,e,a)}))}return e=e?e.then(a,a):a()}})}function j(t){var r={tryLoc:t[0]};1 in t&&(r.catchLoc=t[1]),2 in t&&(r.finallyLoc=t[2],r.afterLoc=t[3]),this.tryEntries.push(r)}function _(t){var
                                                    r=t.completion||{};r.type="normal" ,delete r.arg,t.completion=r}function O(t){this.tryEntries=[{tryLoc: "root"}],t.forEach(j,this),this.reset(!0)}function k(t){if(t){var e,o=t[i];if(o)return o.call(t);if(
                                                    "function"==typeof t.next)return t;if(!isNaN(t.length))return e=-1,(o=function o(){for(;++e<t.length;)if(n.call(t,e))return o.value=t[e],o.done=!1,o;return o.value=r,o.done=!0,o}).next=o}return{next:G}}function G(){return{value:r,done:!0}}return
                                                    o(L, "constructor",{value:d.prototype=m,configurable:!0}),o(m, "constructor",{value:d,configurable:!0}),d.displayName=u(m,c, "GeneratorFunction"),t.isGeneratorFunction=function(t){return!!(t="function"==typeof
                                                    t&&t.constructor)&&(t===d|| "GeneratorFunction"===(t.displayName||t.name))},t.mark=function(t){return Object.setPrototypeOf?Object.setPrototypeOf(t,m):(t.__proto__=m,u(t,c, "GeneratorFunction")),t.prototype=Object.create(L),t},t.awrap=function(t){return{__await:t}},x(E.prototype),u(E.prototype,a,(function(){return
                                                    this})),t.AsyncIterator=E,t.async=function(r,e,n,o,i){void 0===i&&(i=Promise);var a=new E(h(r,e,n,o),i);return t.isGeneratorFunction(e)?a:a.next().then((function(t){return t.done?t.value:a.next()}))},x(L),u(L,c,
                                                    "Generator"),u(L,i,(function(){return this})),u(L, "toString",(function(){return "[object Generator]"})),t.keys=function(t){var r,e=Object(t),n=[];for(r in e)n.push(r);return n.reverse(),function t(){for(;n.length;){var
                                                    r=n.pop();if(r in e)return t.value=r,t.done=!1,t}return t.done=!0,t}},t.values=k,O.prototype={constructor:O,reset:function(t){if(this.prev=0,this.next=0,this.sent=this._sent=r,this.done=!1,this.delegate=null,this.method="next"
                                                    ,this.arg=r,this.tryEntries.forEach(_),!t)for(var e in this) "t"===e.charAt(0)&&n.call(this,e)&&!isNaN(+e.slice(1))&&(this[e]=r)},stop:function(){this.done=!0;var t=this.tryEntries[0].completion;if(
                                                    "throw"===t.type)throw t.arg;return this.rval},dispatchException:function(t){if(this.done)throw t;var e=this;function o(n,o){return c.type="throw" ,c.arg=t,e.next=n,o&&(e.method="next" ,e.arg=r),!!o}for(var i=this.tryEntries.length-1;0<=i;--i){var
                                                    a=this.tryEntries[i],c=a.completion;if( "root"===a.tryLoc)return o( "end");if(a.tryLoc<=this.prev){var u=n.call(a, "catchLoc"),h=n.call(a, "finallyLoc");if(u&&h){if(this.prev<a.catchLoc)return o(a.catchLoc,!0);if(this.prev<a.finallyLoc)return
                                                    o(a.finallyLoc)}else if(u){if(this.prev<a.catchLoc)return o(a.catchLoc,!0)}else{if(!h)throw new Error( "try statement without catch or finally");if(this.prev<a.finallyLoc)return o(a.finallyLoc)}}}},abrupt:function(t,r){for(var
                                                    e=this.tryEntries.length-1;0<=e;--e){var o=this.tryEntries[e];if(o.tryLoc<=this.prev&&n.call(o, "finallyLoc")&&this.prev<o.finallyLoc){var i=o;break}}var a=(i=i&&( "break"===t|| "continue"===t)&&i.tryLoc<=r&&r<=i.finallyLoc?null:i)?i.completion:{};return
                                                    a.type=t,a.arg=r,i?(this.method="next" ,this.next=i.finallyLoc,g):this.complete(a)},complete:function(t,r){if( "throw"===t.type)throw t.arg;return "break"===t.type|| "continue"===t.type?this.next=t.arg:
                                                    "return"===t.type?(this.rval=this.arg=t.arg,this.method="return" ,this.next="end" ): "normal"===t.type&&r&&(this.next=r),g},finish:function(t){for(var r=this.tryEntries.length-1;0<=r;--r){var e=this.tryEntries[r];if(e.finallyLoc===t)return
                                                    this.complete(e.completion,e.afterLoc),_(e),g}},catch:function(t){for(var r=this.tryEntries.length-1;0<=r;--r){var e,n,o=this.tryEntries[r];if(o.tryLoc===t)return "throw"===(e=o.completion).type&&(n=e.arg,_(o)),n}throw
                                                    new Error( "illegal catch attempt")},delegateYield:function(t,e,n){return this.delegate={iterator:k(t),resultName:e,nextLoc:n}, "next"===this.method&&(this.arg=r),g}},t}( "object"==typeof module?module.exports:{});try{regeneratorRuntime=runtime}catch(t){
                                                    "object"==typeof globalThis?globalThis.regeneratorRuntime=runtime:Function( "r", "regeneratorRuntime = r")(runtime)};